import os
import warnings
import numpy as np
import sympy
import pandas as pd
import argparse

# Internal imports
import physo.benchmark.FeynmanDataset.FeynmanProblem as Feyn

# Local imports
import feynman_config as fconfig

# ---------------------------------------------------- SCRIPT ARGS -----------------------------------------------------
parser = argparse.ArgumentParser (description     = "Analyzes Feynman run results folder and produces a .csv summary.",
                                  formatter_class = argparse.ArgumentDefaultsHelpFormatter)
parser.add_argument("-p", "--path", default = ".",
                    help = "Paths to results folder.")
config = vars(parser.parse_args())
RESULTS_PATH = str(config["path"])
# ---------------------------------------------------- SCRIPT ARGS -----------------------------------------------------

N_TRIALS = fconfig.N_TRIALS
EXCLUDED_IN_SRBENCH_EQS_FILENAMES = fconfig.EXCLUDED_IN_SRBENCH_EQS_FILENAMES

# Where to save results summary
PATH_RESULTS_SAVE = os.path.join(RESULTS_PATH, "results.csv")

# First column to contain free constants in Pareto front csv
START_COL_FREE_CONST_PARETO_CSV = 6

# Only assessing symbolic equivalence if reward is above:
R_LIM = 0.6



def load_pareto_expressions (pareto_df, sympy_X_symbols_dict):
    """
    Loads a Pareto front dataframe generated by PhySO into sympy expressions with evaluated free constants.
    Parameters
    ----------
    pareto_df : pd.DataFrame
        Pareto front dataframe generated by PhySO.
    sympy_X_symbols_dict : dict of {str : sympy.Symbol}
        Input variables names to sympy symbols (w assumptions), can be passed to sympy.parsing.sympy_parser.parse_expr
        as local_dict.
    Returns
    -------
    sympy_expressions : array_like of Sympy Expressions
    """
    # Initializing list of sympy expressions
    sympy_expressions = []
    # Names of free constants
    free_consts_names = pareto_df.columns.to_numpy()[START_COL_FREE_CONST_PARETO_CSV:].astype(str)
    # Nb of free constants
    n_fconsts = len(free_consts_names)
    # Iterating through Pareto optima expressions
    for i_expr in range (len(pareto_df)):
        # Expression str
        expr_str = pareto_df["expression"].iloc[i_expr]
        # Free const name to value dict
        free_const_dict = {free_consts_names[i_const]: pareto_df[free_consts_names[i_const]].iloc[i_expr]
                           for i_const in range(n_fconsts)}
        # Variables + const to their values or symbols dict
        local_dict = {}
        local_dict.update(sympy_X_symbols_dict)
        local_dict.update(free_const_dict)
        # Sympy formula with free constants replaced by their values and variables symbols having assumptions
        formula_sympy = sympy.parsing.sympy_parser.parse_expr(expr_str,
                                                              local_dict = local_dict,
                                                              evaluate   = True,)
        sympy_expressions.append(formula_sympy)
    return sympy_expressions

def assess_equivalence_in_pareto (pareto_df, Feynman_pb, verbose = False):
    """
    Checks if at least one expression in the Pareto front is symbolically equivalent to target expression, following a
    similar methodology as SRBench (see https://github.com/cavalab/srbench).
    I.e, an expression is deemed equivalent if:
        - the symbolic difference simplifies to 0
        - OR the symbolic difference is a constant
        - OR the symbolic ratio simplifies to a constant
    Parameters
    ----------
    pareto_df : pd.DataFrame
        Pareto front dataframe generated by PhySO.
    Feynman_pb : physo.benchmark.FeynmanDataset.FeynmanProblem.FeynmanProblem
        Related Feynman problem.
    verbose : bool
        Verbose.
    Returns
    -------
    is_equivalent : bool
        Is at least one expression equivalent.
    """
    # Nb of expressions in Pareto front
    n_expr = len(pareto_df)
    # Loading rewards of Pareto fronts
    rewards = pareto_df["reward"].to_numpy()
    # Loading Pareto front expressions
    pareto_expressions = load_pareto_expressions(pareto_df            = pareto_df,
                                                 sympy_X_symbols_dict = Feynman_pb.sympy_X_symbols_dict, )
    is_equivalent_list = []
    # Iterating through Pareto front expressions
    for i in range (n_expr):
        r = rewards[i]
        # Only assessing symbolic equivalence if reward is above threshold
        if r > R_LIM:
            print(" -> reward = %f -> analyzing " % (r))
            is_equivalent = Feynman_pb.compare_expression(trial_expr = pareto_expressions[i],
                                                          verbose    = verbose)
            is_equivalent_list.append(is_equivalent)
            if r > 0.9900 and (is_equivalent is False):
                print("  -> Weird reward = %f and yet this expression was not deemed equivalent."%(r))
        else:
            print(" -> reward = %f < %f -> no need to analyze further"%(r, R_LIM))

    is_equivalent_list = np.array(is_equivalent_list)
    # Is any equivalent ?
    is_equivalent      = is_equivalent_list.any()
    return is_equivalent

# Results df settings
column_names = ["Eq Nb"] + ["Trial %i"%(i) for i in range(N_TRIALS)] + ["Recovery Rate"]
column_dtypes = {"Eq Nb": int, "Recovery Rate" : float}
column_dtypes.update({"Trial %i"%(i) : bool for i in range(N_TRIALS)})
results_lines = []

# Iterating through Feynman problems
for i_eq in range (Feyn.N_EQS):
    print("\nProblem #%i"%(i_eq))
    # Loading a problem
    pb = Feyn.FeynmanProblem(i_eq)
    # Considering the problem only if it is not excluded
    if pb.eq_filename not in EXCLUDED_IN_SRBENCH_EQS_FILENAMES:
        print(pb)
        is_equivalent_list = []
        # Iterating through trials
        for i_trial in range (N_TRIALS):
            # Run folder
            pb_folder_prefix = "FR_%s_%s"%(i_eq, i_trial)
            # Getting folder starting with [pb_folder_prefix] str
            # Working with prefix only is better to
            pb_folder   = list(filter(lambda folders: pb_folder_prefix in folders, os.listdir(RESULTS_PATH)))
            if len(pb_folder)==0:
                warnings.warn("Unable to find folder starting with: %s" % (pb_folder_prefix))
                path_pareto = None
            else:
                pb_folder = pb_folder[0]
                print("-> Analyzing run folder: %s"%(pb_folder))
                path_pareto = os.path.join(RESULTS_PATH, pb_folder, 'SR_curves_pareto.csv')
            try:
                # Loading pareto expressions
                pareto_data = pd.read_csv(path_pareto)
                # Compare expressions
                is_equivalent = assess_equivalence_in_pareto (pareto_df = pareto_data, Feynman_pb = pb, verbose = True)
            except:
                warnings.warn("Unable to load file: %s"%(path_pareto))
                is_equivalent = False
            is_equivalent_list .append(is_equivalent)
        # Logging result line
        recov_rate = np.sum(is_equivalent_list)/N_TRIALS
        data = np.array([i_eq] + is_equivalent_list + [recov_rate])[:, np.newaxis].transpose()
        result_line = pd.DataFrame(data    = data,
                                   columns = column_names)
        results_lines.append(result_line)
        # Updating results csv
        results_df = pd.concat(results_lines, ignore_index=True, axis=0)
        results_df = results_df.astype(column_dtypes)
        results_df.to_csv(PATH_RESULTS_SAVE)
    else:
        print("Problem excluded.")

total_recov_rate = results_df["Recovery Rate"].mean()
print("\n\nTotal recovery rate = %f"%(total_recov_rate))